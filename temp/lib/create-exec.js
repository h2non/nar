// Generated by LiveScript 1.2.0
var fw, path, ncp, pack, unpack, create, download, exec, EventEmitter, dirname, join, basename, ref$, rm, mk, isWin, tmpdir, copyBinary, rename, exists, once, extend, handleExit, arch, script, downloadUrl, supportedPlatforms, supportedArchs, supportedVersions, apply, findIndex, matchVersion, sameNodeBinary, setOs, setArch, setNode;
fw = require('fw');
path = require('path');
ncp = require('ncp').ncp;
pack = require('./pack');
unpack = require('./unpack');
create = require('./create');
download = require('./download');
exec = require('child_process').exec;
EventEmitter = require('events').EventEmitter;
dirname = path.dirname, join = path.join, basename = path.basename;
ref$ = require('./utils'), rm = ref$.rm, mk = ref$.mk, isWin = ref$.isWin, tmpdir = ref$.tmpdir, copyBinary = ref$.copyBinary, rename = ref$.rename, exists = ref$.exists, once = ref$.once, extend = ref$.extend, handleExit = ref$.handleExit, arch = ref$.arch;
script = join(__dirname, '..', 'scripts/run.sh');
downloadUrl = 'http://nodejs.org/dist';
supportedPlatforms = ['linux', 'darwin', 'sunos'];
supportedArchs = ['x86', 'x64'];
supportedVersions = [/^0.8.[0-9]+/, /^0.9.[0-9]+/, /^0.10.[0-9]+/, /^0.11.[0-9]+/, /^0.12.[0-9]+/];
module.exports = function(options){
  var emitter, dest, tmpPath, tmpDownload, nodeBinary, clean, onError, onDownloadError, onEntry, onEnd, onCreateEnd, onProgress, onDownload, onDownloadEnd, getBinaryType, createExecutable;
  emitter = new EventEmitter;
  options = apply(
  options);
  dest = options.dest || process.cwd();
  tmpPath = tmpdir();
  tmpDownload = null;
  options.dest = tmpPath;
  nodeBinary = null;
  clean = function(){
    emitter.emit('message', 'Cleaning temporary directories');
    try {
      rm(
      tmpPath);
      if (tmpDownload) {
        return rm(
        tmpDownload);
      }
    } catch (e$) {}
  };
  onError = once(function(err){
    clean();
    return emitter.emit('error', err);
  });
  onDownloadError = function(err){
    return onError(
    err);
  };
  onEntry = function(it){
    if (it) {
      return emitter.emit('entry', it);
    }
  };
  onEnd = function(it){
    clean();
    return emitter.emit('end', it);
  };
  onCreateEnd = function(narPath){
    return createExecutable(
    narPath);
  };
  onProgress = function(status){
    return emitter.emit('progress', status);
  };
  onDownload = function(){
    return emitter.emit(
    'download');
  };
  onDownloadEnd = function(it){
    return emitter.emit('downloadEnd', it);
  };
  getBinaryType = function(){
    var os, arch;
    os = options.os, arch = options.arch;
    return os + "-" + arch;
  };
  createExecutable = function(nar){
    var narFile, narPath, narOutput, cleanExec, copyNodeBinary, copyNarPkg, createTarball, createBinary, generate, extractBinary, downloadBinary;
    narFile = basename(nar, '.nar');
    narPath = join(dest, narFile) + '.run';
    narOutput = join(dest, narFile) + ("-" + getBinaryType() + ".nar");
    cleanExec = function(){
      rm(
      narPath);
      return clean();
    };
    copyNodeBinary = function(done){
      var binDir;
      binDir = join(tmpPath, 'bin');
      mk(
      binDir);
      return copyBinary(nodeBinary || process.execPath, binDir, done);
    };
    copyNarPkg = function(done){
      var dest, narPath;
      dest = join(tmpPath, 'nar');
      narPath = join(__dirname, '..');
      return ncp(narPath, dest, done);
    };
    createTarball = function(done){
      var config;
      config = {
        name: basename(nar, '.nar'),
        dest: dest,
        patterns: ['**'],
        src: tmpPath,
        ext: 'run',
        gzip: true
      };
      return pack(
      config).on('error', done).on('entry', onEntry).on('end', function(){
        return done();
      });
    };
    createBinary = function(done){
      var cmd;
      cmd = isWin ? 'type' : 'cat';
      return exec(cmd + " " + script + " " + narPath + " > " + narOutput, done);
    };
    generate = function(){
      emitter.emit(
      'generate');
      return fw.parallel([copyNodeBinary, copyNarPkg], function(err){
        if (err) {
          return onError(
          new Error('cannot copy files to temporal directory'));
        }
        return fw.series([createTarball, createBinary], function(err){
          if (err) {
            return onError(
            new Error('cannot create the executable'));
          }
          cleanExec();
          return emitter.emit('end', narOutput);
        });
      });
    };
    extractBinary = function(options){
      options.gzip = true;
      return unpack(
      options).on('error', onError).on('end', function(){
        nodeBinary = join(options.dest, options.name, 'bin', 'node');
        return generate();
      });
    };
    downloadBinary = function(){
      var node, name, url, dest;
      node = options.node;
      name = "node-" + node + "-" + getBinaryType();
      url = downloadUrl + "/" + node + "/" + name + ".tar.gz";
      dest = tmpDownload = tmpdir();
      return download(
      {
        url: url,
        dest: dest,
        proxy: options.proxy
      }).on('download', onDownload).on('progress', onProgress).on('error', onDownloadError).on('end', function(it){
        onDownloadEnd(
        it);
        return extractBinary(
        {
          path: it,
          dest: dest,
          name: name
        });
      });
    };
    if (!sameNodeBinary(
    options)) {
      return downloadBinary();
    } else {
      return generate();
    }
  };
  if (isWin && options.os === 'win32') {
    return onError(
    new Error('Windows do not support nar executables. Use --os <linux|darwin|sunos>'));
  }
  mk(tmpPath);
  handleExit(
  clean);
  create(
  options).on('error', onError).on('entry', onEntry).on('end', onCreateEnd).on('start', function(){
    return emitter.emit(
    'start');
  }).on('archive', function(it){
    return emitter.emit('archive', it);
  });
  return emitter;
};
apply = function(options){
  setOs(
  options);
  setArch(
  options);
  setNode(
  options);
  return options;
};
findIndex = function(arr, item){
  return arr.indexOf(item) !== -1;
};
matchVersion = function(version){
  return supportedVersions.filter(function(it){
    return it.test(version);
  }).length !== 0;
};
sameNodeBinary = function(options){
  var os, arch, node;
  os = options.os, arch = options.arch, node = options.node;
  return os === process.platform && arch === process.arch && node === process.version;
};
setOs = function(options){
  var os;
  os = options.os;
  if (os) {
    if (findIndex(supportedPlatforms, os)) {
      return options.os = os, options;
    } else {
      throw new Error("Invalid OS platform '" + os + "'. Only " + supportedPlatforms.join(', ') + " are supported");
    }
  } else {
    return options.os = process.platform, options;
  }
};
setArch = function(options){
  var arch;
  arch = options.arch;
  if (arch) {
    if (findIndex(supportedArchs, arch)) {
      return options.arch = arch, options;
    } else {
      throw new Error("Invalid architecture '" + arch + "'. Only x86 or x64 are supported");
    }
  } else {
    return options.arch = process.arch, options;
  }
};
setNode = function(options){
  var node;
  node = options.node;
  if (node) {
    if (node === 'latest') {
      return options.node = 'latest', options;
    } else if (matchVersion(
    node)) {
      return options.node = "v" + node, options;
    } else {
      throw new Error("Invalid node version '" + node + "'");
    }
  } else {
    return options.node = process.version, options;
  }
};
